const jsContent = 'const pressureLevels = [\n  10,\n  15,\n  20,\n  30,\n  40,\n  50,\n  70,\n  75,\n  100,\n  125,\n  150,\n  175,\n  200,\n  225,\n  250,\n  275,\n  300,\n  325,\n  350,\n  375,\n  400,\n  425,\n  450,\n  475,\n  500,\n  525,\n  550,\n  575,\n  600,\n  625,\n  650,\n  675,\n  700,\n  725,\n  750,\n  775,\n  800,\n  825,\n  850,\n  875,\n  900,\n  925,\n  950,\n  970,\n  975,\n  985,\n  1e3,\n  1015\n];\nconst heights = [\n  2,\n  10,\n  20,\n  30,\n  40,\n  50,\n  75,\n  80,\n  100,\n  120,\n  150,\n  200,\n  250,\n  300,\n  400,\n  500,\n  600,\n  700,\n  800,\n  1e3,\n  1250,\n  1500,\n  1750,\n  2e3,\n  2250,\n  2500,\n  2750,\n  3e3,\n  3250,\n  3500,\n  3750,\n  4e3,\n  4500,\n  5e3,\n  5500,\n  6e3\n];\nfor (const pl of pressureLevels) {\n}\nfor (const height of heights) {\n}\nconst hideZero = [\n  "rain",\n  "cloud_cover",\n  "precipitation",\n  "convective_cloud_top",\n  "convective_cloud_base"\n];\nconst drawOnTiles = ["pressure_msl"];\nconst PI = Math.PI;\nconst degreesToRadians = (degree) => {\n  return degree * (PI / 180);\n};\nconst radiansToDegrees = (rad) => {\n  return rad * (180 / PI);\n};\nconst tile2lon = (x, z) => {\n  return x / Math.pow(2, z) * 360 - 180;\n};\nconst tile2lat = (y, z) => {\n  const n = PI - 2 * PI * y / Math.pow(2, z);\n  return radiansToDegrees(Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));\n};\nconst lon2tile = (lon, z) => {\n  return Math.pow(2, z) * ((lon + 180) / 360);\n};\nconst lat2tile = (lat, z) => {\n  return Math.pow(2, z) * (1 - Math.log(Math.tan(degreesToRadians(lat)) + 1 / Math.cos(degreesToRadians(lat))) / PI) / 2;\n};\nconst getIndexFromLatLong = (lat, lon, dx, dy, nx, latLonMinMax) => {\n  if (lat < latLonMinMax[0] || lat >= latLonMinMax[2] || lon < latLonMinMax[1] || lon >= latLonMinMax[3]) {\n    return { index: NaN, xFraction: 0, yFraction: 0 };\n  } else {\n    const x = Math.floor((lon - latLonMinMax[1]) / dx);\n    const y = Math.floor((lat - latLonMinMax[0]) / dy);\n    const xFraction = (lon - latLonMinMax[1]) % dx / dx;\n    const yFraction = (lat - latLonMinMax[0]) % dy / dy;\n    const index = y * nx + x;\n    return { index, xFraction, yFraction };\n  }\n};\nconst rotatePoint = (cx, cy, theta, x, y) => {\n  const xt = Math.cos(theta) * (x - cx) - Math.sin(theta) * (y - cy) + cx;\n  const yt = Math.sin(theta) * (x - cx) + Math.cos(theta) * (y - cy) + cy;\n  return [xt, yt];\n};\nclass MercatorProjection {\n  forward(latitude, longitude) {\n    const x = lon2tile(longitude, 0);\n    const y = lat2tile(latitude, 0);\n    return [x, y];\n  }\n  reverse(x, y) {\n    const lon = tile2lon(x, 0);\n    const lat = tile2lat(y, 0);\n    return [lat, lon];\n  }\n}\nclass RotatedLatLonProjection {\n  constructor(projectionData) {\n    if (projectionData) {\n      const rotation = projectionData.rotation ?? [0, 0];\n      this.θ = degreesToRadians(90 + rotation[0]);\n      this.ϕ = degreesToRadians(rotation[1]);\n    } else {\n      throw new Error("projectionData not defined");\n    }\n  }\n  forward(latitude, longitude) {\n    const lon = degreesToRadians(longitude);\n    const lat = degreesToRadians(latitude);\n    const x1 = Math.cos(lon) * Math.cos(lat);\n    const y1 = Math.sin(lon) * Math.cos(lat);\n    const z1 = Math.sin(lat);\n    const x2 = Math.cos(this.θ) * Math.cos(this.ϕ) * x1 + Math.cos(this.θ) * Math.sin(this.ϕ) * y1 + Math.sin(this.θ) * z1;\n    const y2 = -Math.sin(this.ϕ) * x1 + Math.cos(this.ϕ) * y1;\n    const z2 = -Math.sin(this.θ) * Math.cos(this.ϕ) * x1 - Math.sin(this.θ) * Math.sin(this.ϕ) * y1 + Math.cos(this.θ) * z1;\n    const x = -1 * radiansToDegrees(Math.atan2(y2, x2));\n    const y = -1 * radiansToDegrees(Math.asin(z2));\n    return [x, y];\n  }\n  reverse(x, y) {\n    const lon1 = degreesToRadians(x);\n    const lat1 = degreesToRadians(y);\n    const lat2 = -1 * Math.asin(\n      Math.cos(this.θ) * Math.sin(lat1) - Math.cos(lon1) * Math.sin(this.θ) * Math.cos(lat1)\n    );\n    const lon2 = -1 * (Math.atan2(\n      Math.sin(lon1),\n      Math.tan(lat1) * Math.sin(this.θ) + Math.cos(lon1) * Math.cos(this.θ)\n    ) - this.ϕ);\n    const lon = (radiansToDegrees(lon2) + 180) % 360 - 180;\n    const lat = radiansToDegrees(lat2);\n    return [lat, lon];\n  }\n}\nclass LambertConformalConicProjection {\n  // Radius of the Earth\n  constructor(projectionData) {\n    this.R = 6370.997;\n    let λ0_dec;\n    let ϕ0_dec;\n    let ϕ1_dec;\n    let ϕ2_dec;\n    let radius;\n    if (projectionData) {\n      λ0_dec = projectionData.λ0;\n      ϕ0_dec = projectionData.ϕ0;\n      ϕ1_dec = projectionData.ϕ1;\n      ϕ2_dec = projectionData.ϕ2;\n      radius = projectionData.radius;\n    } else {\n      throw new Error("projectionData not defined");\n    }\n    this.λ0 = degreesToRadians((λ0_dec + 180) % 360 - 180);\n    const ϕ0 = degreesToRadians(ϕ0_dec);\n    const ϕ1 = degreesToRadians(ϕ1_dec);\n    const ϕ2 = degreesToRadians(ϕ2_dec);\n    if (ϕ1 == ϕ2) {\n      this.n = Math.sin(ϕ1);\n    } else {\n      this.n = Math.log(Math.cos(ϕ1) / Math.cos(ϕ2)) / Math.log(Math.tan(Math.PI / 4 + ϕ2 / 2) / Math.tan(Math.PI / 4 + ϕ1 / 2));\n    }\n    this.F = Math.cos(ϕ1) * Math.pow(Math.tan(Math.PI / 4 + ϕ1 / 2), this.n) / this.n;\n    this.ρ0 = this.F / Math.pow(Math.tan(Math.PI / 4 + ϕ0 / 2), this.n);\n    if (radius) {\n      this.R = radius;\n    }\n  }\n  forward(latitude, longitude) {\n    const ϕ = degreesToRadians(latitude);\n    const λ = degreesToRadians(longitude);\n    const θ = this.n * (λ - this.λ0);\n    const p = this.F / Math.pow(Math.tan(Math.PI / 4 + ϕ / 2), this.n);\n    const x = this.R * p * Math.sin(θ);\n    const y = this.R * (this.ρ0 - p * Math.cos(θ));\n    return [x, y];\n  }\n  reverse(x, y) {\n    const x_scaled = x / this.R;\n    const y_scaled = y / this.R;\n    const θ = this.n >= 0 ? Math.atan2(x_scaled, this.ρ0 - y_scaled) : Math.atan2(-1 * x_scaled, y_scaled - this.ρ0);\n    const ρ = (this.n > 0 ? 1 : -1) * Math.sqrt(Math.pow(x_scaled, 2) + Math.pow(this.ρ0 - y_scaled, 2));\n    const ϕ_rad = 2 * Math.atan(Math.pow(this.F / ρ, 1 / this.n)) - Math.PI / 2;\n    const λ_rad = this.λ0 + θ / this.n;\n    const λ = radiansToDegrees(λ_rad);\n    const lat = radiansToDegrees(ϕ_rad);\n    const lon = λ > 180 ? λ - 360 : λ;\n    return [lat, lon];\n  }\n}\nclass LambertAzimuthalEqualAreaProjection {\n  // Radius of the Earth\n  constructor(projectionData) {\n    this.R = 6371229;\n    if (projectionData) {\n      const λ0_dec = projectionData.λ0;\n      const ϕ1_dec = projectionData.ϕ1;\n      const radius = projectionData.radius;\n      this.λ0 = degreesToRadians(λ0_dec);\n      this.ϕ1 = degreesToRadians(ϕ1_dec);\n      if (radius) {\n        this.R = radius;\n      }\n    } else {\n      throw new Error("projectionData not defined");\n    }\n  }\n  forward(latitude, longitude) {\n    const λ = degreesToRadians(longitude);\n    const ϕ = degreesToRadians(latitude);\n    const k = Math.sqrt(\n      2 / (1 + Math.sin(this.ϕ1) * Math.sin(ϕ) + Math.cos(this.ϕ1) * Math.cos(ϕ) * Math.cos(λ - this.λ0))\n    );\n    const x = this.R * k * Math.cos(ϕ) * Math.sin(λ - this.λ0);\n    const y = this.R * k * (Math.cos(this.ϕ1) * Math.sin(ϕ) - Math.sin(this.ϕ1) * Math.cos(ϕ) * Math.cos(λ - this.λ0));\n    return [x, y];\n  }\n  reverse(x, y) {\n    x = x / this.R;\n    y = y / this.R;\n    const ρ = Math.sqrt(x * x + y * y);\n    const c = 2 * Math.asin(0.5 * ρ);\n    const ϕ = Math.asin(\n      Math.cos(c) * Math.sin(this.ϕ1) + y * Math.sin(c) * Math.cos(this.ϕ1) / ρ\n    );\n    const λ = this.λ0 + Math.atan(\n      x * Math.sin(c) / (ρ * Math.cos(this.ϕ1) * Math.cos(c) - y * Math.sin(this.ϕ1) * Math.sin(c))\n    );\n    const lat = radiansToDegrees(ϕ);\n    const lon = radiansToDegrees(λ);\n    return [lat, lon];\n  }\n}\nclass StereograpicProjection {\n  // Radius of Earth\n  constructor(projectionData) {\n    this.R = 6371229;\n    if (projectionData) {\n      this.λ0 = degreesToRadians(projectionData.longitude);\n      this.sinϕ1 = Math.sin(degreesToRadians(projectionData.latitude));\n      this.cosϕ1 = Math.cos(degreesToRadians(projectionData.latitude));\n      if (projectionData.radius) {\n        this.R = projectionData.radius;\n      }\n    } else {\n      throw new Error("projectionData not defined");\n    }\n  }\n  forward(latitude, longitude) {\n    const ϕ = degreesToRadians(latitude);\n    const λ = degreesToRadians(longitude);\n    const k = 2 * this.R / (1 + this.sinϕ1 * Math.sin(ϕ) + this.cosϕ1 * Math.cos(ϕ) * Math.cos(λ - this.λ0));\n    const x = k * Math.cos(ϕ) * Math.sin(λ - this.λ0);\n    const y = k * (this.cosϕ1 * Math.sin(ϕ) - this.sinϕ1 * Math.cos(ϕ) * Math.cos(λ - this.λ0));\n    return [x, y];\n  }\n  reverse(x, y) {\n    const p = Math.sqrt(x * x + y * y);\n    const c = 2 * Math.atan2(p, 2 * this.R);\n    const ϕ = Math.asin(Math.cos(c) * this.sinϕ1 + y * Math.sin(c) * this.cosϕ1 / p);\n    const λ = this.λ0 + Math.atan2(x * Math.sin(c), p * this.cosϕ1 * Math.cos(c) - y * this.sinϕ1 * Math.sin(c));\n    const lat = radiansToDegrees(ϕ);\n    const lon = radiansToDegrees(λ);\n    return [lat, lon];\n  }\n}\nconst projections = {\n  MercatorProjection,\n  StereograpicProjection,\n  RotatedLatLonProjection,\n  LambertConformalConicProjection,\n  LambertAzimuthalEqualAreaProjection\n};\nclass DynamicProjection {\n  constructor(projName, opts) {\n    return new projections[projName](opts);\n  }\n}\nclass ProjectionGrid {\n  constructor(projection, grid, ranges = [\n    { start: 0, end: grid.ny },\n    { start: 0, end: grid.nx }\n  ]) {\n    this.ranges = ranges;\n    this.projection = projection;\n    const latitude = grid.projection?.latitude ?? grid.latMin;\n    const longitude = grid.projection?.longitude ?? grid.lonMin;\n    const projectOrigin = grid.projection?.projectOrigin ?? true;\n    this.nx = grid.nx;\n    this.ny = grid.ny;\n    if (latitude && Array === latitude.constructor && Array === longitude.constructor) {\n      const sw = projection.forward(latitude[0], longitude[0]);\n      const ne = projection.forward(latitude[1], longitude[1]);\n      this.origin = sw;\n      this.dx = (ne[0] - sw[0]) / this.nx;\n      this.dy = (ne[1] - sw[1]) / this.ny;\n    } else if (projectOrigin) {\n      this.dx = grid.dx;\n      this.dy = grid.dy;\n      this.origin = this.projection.forward(latitude, longitude);\n    } else {\n      this.dx = grid.dx;\n      this.dy = grid.dy;\n      this.origin = [latitude, longitude];\n    }\n  }\n  findPointInterpolated(lat, lon, ranges) {\n    const [xPos, yPos] = this.projection.forward(lat, lon);\n    const minX = this.origin[0] + this.dx * ranges[1]["start"];\n    const minY = this.origin[1] + this.dy * ranges[0]["start"];\n    const x = (xPos - minX) / this.dx;\n    const y = (yPos - minY) / this.dy;\n    const xFraction = x - Math.floor(x);\n    const yFraction = y - Math.floor(y);\n    if (x < 0 || x >= ranges[1]["end"] - ranges[1]["start"] || y < 0 || y >= ranges[0]["end"] - ranges[0]["start"]) {\n      return { index: NaN, xFraction: 0, yFraction: 0 };\n    }\n    const index = Math.floor(y) * (ranges[1]["end"] - ranges[1]["start"]) + Math.floor(x);\n    return { index, xFraction, yFraction };\n  }\n}\nvar noop = { value: () => {\n} };\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + "") || t in _ || /[\\s.]/.test(t)) throw new Error("illegal type: " + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\nfunction Dispatch(_) {\n  this._ = _;\n}\nfunction parseTypenames$1(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = "", i = t.indexOf(".");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);\n    return { type: t, name };\n  });\n}\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._, T = parseTypenames$1(typename + "", _), t, i = -1, n = T.length;\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;\n      return;\n    }\n    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);\n    }\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\nfunction get$1(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\nfunction set$1(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({ name, value: callback });\n  return type;\n}\nvar xhtml = "http://www.w3.org/1999/xhtml";\nvar namespaces = {\n  svg: "http://www.w3.org/2000/svg",\n  xhtml,\n  xlink: "http://www.w3.org/1999/xlink",\n  xml: "http://www.w3.org/XML/1998/namespace",\n  xmlns: "http://www.w3.org/2000/xmlns/"\n};\nfunction namespace(name) {\n  var prefix = name += "", i = prefix.indexOf(":");\n  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);\n  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;\n}\nfunction creatorInherit(name) {\n  return function() {\n    var document2 = this.ownerDocument, uri = this.namespaceURI;\n    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);\n  };\n}\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\nfunction creator(name) {\n  var fullname = namespace(name);\n  return (fullname.local ? creatorFixed : creatorInherit)(fullname);\n}\nfunction none() {\n}\nfunction selector(selector2) {\n  return selector2 == null ? none : function() {\n    return this.querySelector(selector2);\n  };\n}\nfunction selection_select(select) {\n  if (typeof select !== "function") select = selector(select);\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n        if ("__data__" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n      }\n    }\n  }\n  return new Selection$1(subgroups, this._parents);\n}\nfunction array(x) {\n  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);\n}\nfunction empty() {\n  return [];\n}\nfunction selectorAll(selector2) {\n  return selector2 == null ? empty : function() {\n    return this.querySelectorAll(selector2);\n  };\n}\nfunction arrayAll(select) {\n  return function() {\n    return array(select.apply(this, arguments));\n  };\n}\nfunction selection_selectAll(select) {\n  if (typeof select === "function") select = arrayAll(select);\n  else select = selectorAll(select);\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        subgroups.push(select.call(node, node.__data__, i, group));\n        parents.push(node);\n      }\n    }\n  }\n  return new Selection$1(subgroups, parents);\n}\nfunction matcher(selector2) {\n  return function() {\n    return this.matches(selector2);\n  };\n}\nfunction childMatcher(selector2) {\n  return function(node) {\n    return node.matches(selector2);\n  };\n}\nvar find = Array.prototype.find;\nfunction childFind(match) {\n  return function() {\n    return find.call(this.children, match);\n  };\n}\nfunction childFirst() {\n  return this.firstElementChild;\n}\nfunction selection_selectChild(match) {\n  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));\n}\nvar filter = Array.prototype.filter;\nfunction children() {\n  return Array.from(this.children);\n}\nfunction childrenFilter(match) {\n  return function() {\n    return filter.call(this.children, match);\n  };\n}\nfunction selection_selectChildren(match) {\n  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));\n}\nfunction selection_filter(match) {\n  if (typeof match !== "function") match = matcher(match);\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n  return new Selection$1(subgroups, this._parents);\n}\nfunction sparse(update) {\n  return new Array(update.length);\n}\nfunction selection_enter() {\n  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);\n}\nfunction EnterNode(parent, datum2) {\n  this.ownerDocument = parent.ownerDocument;\n  this.namespaceURI = parent.namespaceURI;\n  this._next = null;\n  this._parent = parent;\n  this.__data__ = datum2;\n}\nEnterNode.prototype = {\n  constructor: EnterNode,\n  appendChild: function(child) {\n    return this._parent.insertBefore(child, this._next);\n  },\n  insertBefore: function(child, next) {\n    return this._parent.insertBefore(child, next);\n  },\n  querySelector: function(selector2) {\n    return this._parent.querySelector(selector2);\n  },\n  querySelectorAll: function(selector2) {\n    return this._parent.querySelectorAll(selector2);\n  }\n};\nfunction constant$1(x) {\n  return function() {\n    return x;\n  };\n}\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0, node, groupLength = group.length, dataLength = data.length;\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  }\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + "";\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {\n      exit[i] = node;\n    }\n  }\n}\nfunction datum(node) {\n  return node.__data__;\n}\nfunction selection_data(value, key) {\n  if (!arguments.length) return Array.from(this, datum);\n  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;\n  if (typeof value !== "function") value = constant$1(value);\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;\n        previous._next = next || null;\n      }\n    }\n  }\n  update = new Selection$1(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\nfunction arraylike(data) {\n  return typeof data === "object" && "length" in data ? data : Array.from(data);\n}\nfunction selection_exit() {\n  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);\n}\nfunction selection_join(onenter, onupdate, onexit) {\n  var enter = this.enter(), update = this, exit = this.exit();\n  if (typeof onenter === "function") {\n    enter = onenter(enter);\n    if (enter) enter = enter.selection();\n  } else {\n    enter = enter.append(onenter + "");\n  }\n  if (onupdate != null) {\n    update = onupdate(update);\n    if (update) update = update.selection();\n  }\n  if (onexit == null) exit.remove();\n  else onexit(exit);\n  return enter && update ? enter.merge(update).order() : update;\n}\nfunction selection_merge(context) {\n  var selection2 = context.selection ? context.selection() : context;\n  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n  return new Selection$1(merges, this._parents);\n}\nfunction selection_order() {\n  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {\n    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\n      if (node = group[i]) {\n        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n  return this;\n}\nfunction selection_sort(compare) {\n  if (!compare) compare = ascending;\n  function compareNode(a, b) {\n    return a && b ? compare(a.__data__, b.__data__) : !a - !b;\n  }\n  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        sortgroup[i] = node;\n      }\n    }\n    sortgroup.sort(compareNode);\n  }\n  return new Selection$1(sortgroups, this._parents).order();\n}\nfunction ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\nfunction selection_call() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n}\nfunction selection_nodes() {\n  return Array.from(this);\n}\nfunction selection_node() {\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n  return null;\n}\nfunction selection_size() {\n  let size = 0;\n  for (const node of this) ++size;\n  return size;\n}\nfunction selection_empty() {\n  return !this.node();\n}\nfunction selection_each(callback) {\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {\n      if (node = group[i]) callback.call(node, node.__data__, i, group);\n    }\n  }\n  return this;\n}\nfunction attrRemove$1(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\nfunction attrRemoveNS$1(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\nfunction attrConstant$1(name, value) {\n  return function() {\n    this.setAttribute(name, value);\n  };\n}\nfunction attrConstantNS$1(fullname, value) {\n  return function() {\n    this.setAttributeNS(fullname.space, fullname.local, value);\n  };\n}\nfunction attrFunction$1(name, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttribute(name);\n    else this.setAttribute(name, v);\n  };\n}\nfunction attrFunctionNS$1(fullname, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);\n    else this.setAttributeNS(fullname.space, fullname.local, v);\n  };\n}\nfunction selection_attr(name, value) {\n  var fullname = namespace(name);\n  if (arguments.length < 2) {\n    var node = this.node();\n    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);\n  }\n  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));\n}\nfunction defaultView(node) {\n  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;\n}\nfunction styleRemove$1(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\nfunction styleConstant$1(name, value, priority) {\n  return function() {\n    this.style.setProperty(name, value, priority);\n  };\n}\nfunction styleFunction$1(name, value, priority) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, v, priority);\n  };\n}\nfunction selection_style(name, value, priority) {\n  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);\n}\nfunction styleValue(node, name) {\n  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);\n}\nfunction propertyRemove(name) {\n  return function() {\n    delete this[name];\n  };\n}\nfunction propertyConstant(name, value) {\n  return function() {\n    this[name] = value;\n  };\n}\nfunction propertyFunction(name, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) delete this[name];\n    else this[name] = v;\n  };\n}\nfunction selection_property(name, value) {\n  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];\n}\nfunction classArray(string) {\n  return string.trim().split(/^|\\s+/);\n}\nfunction classList(node) {\n  return node.classList || new ClassList(node);\n}\nfunction ClassList(node) {\n  this._node = node;\n  this._names = classArray(node.getAttribute("class") || "");\n}\nClassList.prototype = {\n  add: function(name) {\n    var i = this._names.indexOf(name);\n    if (i < 0) {\n      this._names.push(name);\n      this._node.setAttribute("class", this._names.join(" "));\n    }\n  },\n  remove: function(name) {\n    var i = this._names.indexOf(name);\n    if (i >= 0) {\n      this._names.splice(i, 1);\n      this._node.setAttribute("class", this._names.join(" "));\n    }\n  },\n  contains: function(name) {\n    return this._names.indexOf(name) >= 0;\n  }\n};\nfunction classedAdd(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n) list.add(names[i]);\n}\nfunction classedRemove(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n) list.remove(names[i]);\n}\nfunction classedTrue(names) {\n  return function() {\n    classedAdd(this, names);\n  };\n}\nfunction classedFalse(names) {\n  return function() {\n    classedRemove(this, names);\n  };\n}\nfunction classedFunction(names, value) {\n  return function() {\n    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n  };\n}\nfunction selection_classed(name, value) {\n  var names = classArray(name + "");\n  if (arguments.length < 2) {\n    var list = classList(this.node()), i = -1, n = names.length;\n    while (++i < n) if (!list.contains(names[i])) return false;\n    return true;\n  }\n  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));\n}\nfunction textRemove() {\n  this.textContent = "";\n}\nfunction textConstant$1(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\nfunction textFunction$1(value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    this.textContent = v == null ? "" : v;\n  };\n}\nfunction selection_text(value) {\n  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;\n}\nfunction htmlRemove() {\n  this.innerHTML = "";\n}\nfunction htmlConstant(value) {\n  return function() {\n    this.innerHTML = value;\n  };\n}\nfunction htmlFunction(value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    this.innerHTML = v == null ? "" : v;\n  };\n}\nfunction selection_html(value) {\n  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;\n}\nfunction raise() {\n  if (this.nextSibling) this.parentNode.appendChild(this);\n}\nfunction selection_raise() {\n  return this.each(raise);\n}\nfunction lower() {\n  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\nfunction selection_lower() {\n  return this.each(lower);\n}\nfunction selection_append(name) {\n  var create2 = typeof name === "function" ? name : creator(name);\n  return this.select(function() {\n    return this.appendChild(create2.apply(this, arguments));\n  });\n}\nfunction constantNull() {\n  return null;\n}\nfunction selection_insert(name, before) {\n  var create2 = typeof name === "function" ? name : creator(name), select = before == null ? constantNull : typeof before === "function" ? before : selector(before);\n  return this.select(function() {\n    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);\n  });\n}\nfunction remove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\nfunction selection_remove() {\n  return this.each(remove);\n}\nfunction selection_cloneShallow() {\n  var clone = this.cloneNode(false), parent = this.parentNode;\n  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;\n}\nfunction selection_cloneDeep() {\n  var clone = this.cloneNode(true), parent = this.parentNode;\n  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;\n}\nfunction selection_clone(deep) {\n  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);\n}\nfunction selection_datum(value) {\n  return arguments.length ? this.property("__data__", value) : this.node().__data__;\n}\nfunction contextListener(listener) {\n  return function(event) {\n    listener.call(this, event, this.__data__);\n  };\n}\nfunction parseTypenames(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = "", i = t.indexOf(".");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    return { type: t, name };\n  });\n}\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on) return;\n    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.options);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i) on.length = i;\n    else delete this.__on;\n  };\n}\nfunction onAdd(typename, value, options) {\n  return function() {\n    var on = this.__on, o, listener = contextListener(value);\n    if (on) for (var j = 0, m = on.length; j < m; ++j) {\n      if ((o = on[j]).type === typename.type && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.options);\n        this.addEventListener(o.type, o.listener = listener, o.options = options);\n        o.value = value;\n        return;\n      }\n    }\n    this.addEventListener(typename.type, listener, options);\n    o = { type: typename.type, name: typename.name, value, listener, options };\n    if (!on) this.__on = [o];\n    else on.push(o);\n  };\n}\nfunction selection_on(typename, value, options) {\n  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {\n      for (i = 0, o = on[j]; i < n; ++i) {\n        if ((t = typenames[i]).type === o.type && t.name === o.name) {\n          return o.value;\n        }\n      }\n    }\n    return;\n  }\n  on = value ? onAdd : onRemove;\n  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));\n  return this;\n}\nfunction dispatchEvent(node, type, params) {\n  var window2 = defaultView(node), event = window2.CustomEvent;\n  if (typeof event === "function") {\n    event = new event(type, params);\n  } else {\n    event = window2.document.createEvent("Event");\n    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;\n    else event.initEvent(type, false, false);\n  }\n  node.dispatchEvent(event);\n}\nfunction dispatchConstant(type, params) {\n  return function() {\n    return dispatchEvent(this, type, params);\n  };\n}\nfunction dispatchFunction(type, params) {\n  return function() {\n    return dispatchEvent(this, type, params.apply(this, arguments));\n  };\n}\nfunction selection_dispatch(type, params) {\n  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));\n}\nfunction* selection_iterator() {\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {\n      if (node = group[i]) yield node;\n    }\n  }\n}\nvar root = [null];\nfunction Selection$1(groups, parents) {\n  this._groups = groups;\n  this._parents = parents;\n}\nfunction selection() {\n  return new Selection$1([[document.documentElement]], root);\n}\nfunction selection_selection() {\n  return this;\n}\nSelection$1.prototype = selection.prototype = {\n  constructor: Selection$1,\n  select: selection_select,\n  selectAll: selection_selectAll,\n  selectChild: selection_selectChild,\n  selectChildren: selection_selectChildren,\n  filter: selection_filter,\n  data: selection_data,\n  enter: selection_enter,\n  exit: selection_exit,\n  join: selection_join,\n  merge: selection_merge,\n  selection: selection_selection,\n  order: selection_order,\n  sort: selection_sort,\n  call: selection_call,\n  nodes: selection_nodes,\n  node: selection_node,\n  size: selection_size,\n  empty: selection_empty,\n  each: selection_each,\n  attr: selection_attr,\n  style: selection_style,\n  property: selection_property,\n  classed: selection_classed,\n  text: selection_text,\n  html: selection_html,\n  raise: selection_raise,\n  lower: selection_lower,\n  append: selection_append,\n  insert: selection_insert,\n  remove: selection_remove,\n  clone: selection_clone,\n  datum: selection_datum,\n  on: selection_on,\n  dispatch: selection_dispatch,\n  [Symbol.iterator]: selection_iterator\n};\nfunction define(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n}\nfunction extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition) prototype[key] = definition[key];\n  return prototype;\n}\nfunction Color() {\n}\nvar darker = 0.7;\nvar brighter = 1 / darker;\nvar reI = "\\\\s*([+-]?\\\\d+)\\\\s*", reN = "\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*", reP = "\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\\\(${reI},${reI},${reI}\\\\)$`), reRgbPercent = new RegExp(`^rgb\\\\(${reP},${reP},${reP}\\\\)$`), reRgbaInteger = new RegExp(`^rgba\\\\(${reI},${reI},${reI},${reN}\\\\)$`), reRgbaPercent = new RegExp(`^rgba\\\\(${reP},${reP},${reP},${reN}\\\\)$`), reHslPercent = new RegExp(`^hsl\\\\(${reN},${reP},${reP}\\\\)$`), reHslaPercent = new RegExp(`^hsla\\\\(${reN},${reP},${reP},${reN}\\\\)$`);\nvar named = {\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n};\ndefine(Color, color, {\n  copy(channels) {\n    return Object.assign(new this.constructor(), this, channels);\n  },\n  displayable() {\n    return this.rgb().displayable();\n  },\n  hex: color_formatHex,\n  // Deprecated! Use color.formatHex.\n  formatHex: color_formatHex,\n  formatHex8: color_formatHex8,\n  formatHsl: color_formatHsl,\n  formatRgb: color_formatRgb,\n  toString: color_formatRgb\n});\nfunction color_formatHex() {\n  return this.rgb().formatHex();\n}\nfunction color_formatHex8() {\n  return this.rgb().formatHex8();\n}\nfunction color_formatHsl() {\n  return hslConvert(this).formatHsl();\n}\nfunction color_formatRgb() {\n  return this.rgb().formatRgb();\n}\nfunction color(format) {\n  var m, l;\n  format = (format + "").trim().toLowerCase();\n  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;\n}\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);\n}\nfunction rgba(r, g, b, a) {\n  if (a <= 0) r = g = b = NaN;\n  return new Rgb(r, g, b, a);\n}\nfunction rgbConvert(o) {\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Rgb();\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\nfunction rgb(r, g, b, opacity) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n}\nfunction Rgb(r, g, b, opacity) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity;\n}\ndefine(Rgb, rgb, extend(Color, {\n  brighter(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  darker(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  rgb() {\n    return this;\n  },\n  clamp() {\n    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));\n  },\n  displayable() {\n    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);\n  },\n  hex: rgb_formatHex,\n  // Deprecated! Use color.formatHex.\n  formatHex: rgb_formatHex,\n  formatHex8: rgb_formatHex8,\n  formatRgb: rgb_formatRgb,\n  toString: rgb_formatRgb\n}));\nfunction rgb_formatHex() {\n  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;\n}\nfunction rgb_formatHex8() {\n  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;\n}\nfunction rgb_formatRgb() {\n  const a = clampa(this.opacity);\n  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;\n}\nfunction clampa(opacity) {\n  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));\n}\nfunction clampi(value) {\n  return Math.max(0, Math.min(255, Math.round(value) || 0));\n}\nfunction hex(value) {\n  value = clampi(value);\n  return (value < 16 ? "0" : "") + value.toString(16);\n}\nfunction hsla(h, s, l, a) {\n  if (a <= 0) h = s = l = NaN;\n  else if (l <= 0 || l >= 1) h = s = NaN;\n  else if (s <= 0) h = NaN;\n  return new Hsl(h, s, l, a);\n}\nfunction hslConvert(o) {\n  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Hsl();\n  if (o instanceof Hsl) return o;\n  o = o.rgb();\n  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;\n  if (s) {\n    if (r === max) h = (g - b) / s + (g < b) * 6;\n    else if (g === max) h = (b - r) / s + 2;\n    else h = (r - g) / s + 4;\n    s /= l < 0.5 ? max + min : 2 - max - min;\n    h *= 60;\n  } else {\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s, l, o.opacity);\n}\nfunction hsl$1(h, s, l, opacity) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n}\nfunction Hsl(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\ndefine(Hsl, hsl$1, extend(Color, {\n  brighter(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb() {\n    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),\n      this.opacity\n    );\n  },\n  clamp() {\n    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));\n  },\n  displayable() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);\n  },\n  formatHsl() {\n    const a = clampa(this.opacity);\n    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;\n  }\n}));\nfunction clamph(value) {\n  value = (value || 0) % 360;\n  return value < 0 ? value + 360 : value;\n}\nfunction clampt(value) {\n  return Math.max(0, Math.min(1, value || 0));\n}\nfunction hsl2rgb(h, m1, m2) {\n  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;\n}\nvar constant = (x) => () => x;\nfunction linear(a, d) {\n  return function(t) {\n    return a + t * d;\n  };\n}\nfunction exponential(a, b, y) {\n  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {\n    return Math.pow(a + t * b, y);\n  };\n}\nfunction hue(a, b) {\n  var d = b - a;\n  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);\n}\nfunction gamma(y) {\n  return (y = +y) === 1 ? nogamma : function(a, b) {\n    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);\n  };\n}\nfunction nogamma(a, b) {\n  var d = b - a;\n  return d ? linear(a, d) : constant(isNaN(a) ? b : a);\n}\nvar interpolateRgb = (function rgbGamma(y) {\n  var color2 = gamma(y);\n  function rgb$1(start2, end) {\n    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.r = r(t);\n      start2.g = g(t);\n      start2.b = b(t);\n      start2.opacity = opacity(t);\n      return start2 + "";\n    };\n  }\n  rgb$1.gamma = rgbGamma;\n  return rgb$1;\n})(1);\nfunction interpolateNumber(a, b) {\n  return a = +a, b = +b, function(t) {\n    return a * (1 - t) + b * t;\n  };\n}\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, reB = new RegExp(reA.source, "g");\nfunction zero(b) {\n  return function() {\n    return b;\n  };\n}\nfunction one(b) {\n  return function(t) {\n    return b(t) + "";\n  };\n}\nfunction interpolateString(a, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\n  a = a + "", b = b + "";\n  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) {\n      bs = b.slice(bi, bs);\n      if (s[i]) s[i] += bs;\n      else s[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) {\n      if (s[i]) s[i] += bm;\n      else s[++i] = bm;\n    } else {\n      s[++i] = null;\n      q.push({ i, x: interpolateNumber(am, bm) });\n    }\n    bi = reB.lastIndex;\n  }\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s[i]) s[i] += bs;\n    else s[++i] = bs;\n  }\n  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {\n    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);\n    return s.join("");\n  });\n}\nvar degrees = 180 / Math.PI;\nvar identity = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\nfunction decompose(a, b, c, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;\n  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a) * degrees,\n    skewX: Math.atan(skewX) * degrees,\n    scaleX,\n    scaleY\n  };\n}\nvar svgNode;\nfunction parseCss(value) {\n  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");\n  return m.isIdentity ? identity : decompose(m.a, m.b, m.c, m.d, m.e, m.f);\n}\nfunction parseSvg(value) {\n  if (value == null) return identity;\n  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");\n  svgNode.setAttribute("transform", value);\n  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;\n  value = value.matrix;\n  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);\n}\nfunction interpolateTransform(parse, pxComma, pxParen, degParen) {\n  function pop(s) {\n    return s.length ? s.pop() + " " : "";\n  }\n  function translate(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push("translate(", null, pxComma, null, pxParen);\n      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });\n    } else if (xb || yb) {\n      s.push("translate(" + xb + pxComma + yb + pxParen);\n    }\n  }\n  function rotate(a, b, s, q) {\n    if (a !== b) {\n      if (a - b > 180) b += 360;\n      else if (b - a > 180) a += 360;\n      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });\n    } else if (b) {\n      s.push(pop(s) + "rotate(" + b + degParen);\n    }\n  }\n  function skewX(a, b, s, q) {\n    if (a !== b) {\n      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });\n    } else if (b) {\n      s.push(pop(s) + "skewX(" + b + degParen);\n    }\n  }\n  function scale(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(pop(s) + "scale(", null, ",", null, ")");\n      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });\n    } else if (xb !== 1 || yb !== 1) {\n      s.push(pop(s) + "scale(" + xb + "," + yb + ")");\n    }\n  }\n  return function(a, b) {\n    var s = [], q = [];\n    a = parse(a), b = parse(b);\n    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);\n    rotate(a.rotate, b.rotate, s, q);\n    skewX(a.skewX, b.skewX, s, q);\n    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);\n    a = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join("");\n    };\n  };\n}\nvar interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");\nvar interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");\nfunction hsl(hue2) {\n  return function(start2, end) {\n    var h = hue2((start2 = hsl$1(start2)).h, (end = hsl$1(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);\n    return function(t) {\n      start2.h = h(t);\n      start2.s = s(t);\n      start2.l = l(t);\n      start2.opacity = opacity(t);\n      return start2 + "";\n    };\n  };\n}\nvar interpolateHsl = hsl(hue);\nvar frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {\n  setTimeout(f, 17);\n};\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\nfunction clearNow() {\n  clockNow = 0;\n}\nfunction Timer() {\n  this._call = this._time = this._next = null;\n}\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time) {\n    if (typeof callback !== "function") throw new TypeError("callback is not a function");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\nfunction timer(callback, delay, time) {\n  var t = new Timer();\n  t.restart(callback, delay, time);\n  return t;\n}\nfunction timerFlush() {\n  now();\n  ++frame;\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);\n    t = t._next;\n  }\n  --frame;\n}\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout$1 = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\nfunction poke() {\n  var now2 = clock.now(), delay = now2 - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;\n}\nfunction nap() {\n  var t0, t1 = taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\nfunction sleep(time) {\n  if (frame) return;\n  if (timeout$1) timeout$1 = clearTimeout(timeout$1);\n  var delay = time - clockNow;\n  if (delay > 24) {\n    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\nfunction timeout(callback, delay, time) {\n  var t = new Timer();\n  delay = delay == null ? 0 : +delay;\n  t.restart((elapsed) => {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time);\n  return t;\n}\nvar emptyOn = dispatch("start", "end", "cancel", "interrupt");\nvar emptyTween = [];\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\nfunction schedule(node, name, id2, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id2 in schedules) return;\n  create(node, id2, {\n    name,\n    index,\n    // For context during callback.\n    group,\n    // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\nfunction init(node, id2) {\n  var schedule2 = get(node, id2);\n  if (schedule2.state > CREATED) throw new Error("too late; already scheduled");\n  return schedule2;\n}\nfunction set(node, id2) {\n  var schedule2 = get(node, id2);\n  if (schedule2.state > STARTED) throw new Error("too late; already running");\n  return schedule2;\n}\nfunction get(node, id2) {\n  var schedule2 = node.__transition;\n  if (!schedule2 || !(schedule2 = schedule2[id2])) throw new Error("transition not found");\n  return schedule2;\n}\nfunction create(node, id2, self2) {\n  var schedules = node.__transition, tween;\n  schedules[id2] = self2;\n  self2.timer = timer(schedule2, 0, self2.time);\n  function schedule2(elapsed) {\n    self2.state = SCHEDULED;\n    self2.timer.restart(start2, self2.delay, self2.time);\n    if (self2.delay <= elapsed) start2(elapsed - self2.delay);\n  }\n  function start2(elapsed) {\n    var i, j, n, o;\n    if (self2.state !== SCHEDULED) return stop();\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self2.name) continue;\n      if (o.state === STARTED) return timeout(start2);\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call("interrupt", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      } else if (+i < id2) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call("cancel", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    }\n    timeout(function() {\n      if (self2.state === STARTED) {\n        self2.state = RUNNING;\n        self2.timer.restart(tick, self2.delay, self2.time);\n        tick(elapsed);\n      }\n    });\n    self2.state = STARTING;\n    self2.on.call("start", node, node.__data__, self2.index, self2.group);\n    if (self2.state !== STARTING) return;\n    self2.state = STARTED;\n    tween = new Array(n = self2.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n  function tick(elapsed) {\n    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;\n    while (++i < n) {\n      tween[i].call(node, t);\n    }\n    if (self2.state === ENDING) {\n      self2.on.call("end", node, node.__data__, self2.index, self2.group);\n      stop();\n    }\n  }\n  function stop() {\n    self2.state = ENDED;\n    self2.timer.stop();\n    delete schedules[id2];\n    for (var i in schedules) return;\n    delete node.__transition;\n  }\n}\nfunction interrupt(node, name) {\n  var schedules = node.__transition, schedule2, active, empty2 = true, i;\n  if (!schedules) return;\n  name = name == null ? null : name + "";\n  for (i in schedules) {\n    if ((schedule2 = schedules[i]).name !== name) {\n      empty2 = false;\n      continue;\n    }\n    active = schedule2.state > STARTING && schedule2.state < ENDING;\n    schedule2.state = ENDED;\n    schedule2.timer.stop();\n    schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);\n    delete schedules[i];\n  }\n  if (empty2) delete node.__transition;\n}\nfunction selection_interrupt(name) {\n  return this.each(function() {\n    interrupt(this, name);\n  });\n}\nfunction tweenRemove(id2, name) {\n  var tween0, tween1;\n  return function() {\n    var schedule2 = set(this, id2), tween = schedule2.tween;\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n    schedule2.tween = tween1;\n  };\n}\nfunction tweenFunction(id2, name, value) {\n  var tween0, tween1;\n  if (typeof value !== "function") throw new Error();\n  return function() {\n    var schedule2 = set(this, id2), tween = schedule2.tween;\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n      if (i === n) tween1.push(t);\n    }\n    schedule2.tween = tween1;\n  };\n}\nfunction transition_tween(name, value) {\n  var id2 = this._id;\n  name += "";\n  if (arguments.length < 2) {\n    var tween = get(this.node(), id2).tween;\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n    return null;\n  }\n  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));\n}\nfunction tweenValue(transition, name, value) {\n  var id2 = transition._id;\n  transition.each(function() {\n    var schedule2 = set(this, id2);\n    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);\n  });\n  return function(node) {\n    return get(node, id2).value[name];\n  };\n}\nfunction interpolate(a, b) {\n  var c;\n  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);\n}\nfunction attrRemove(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\nfunction attrRemoveNS(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\nfunction attrConstant(name, interpolate2, value1) {\n  var string00, string1 = value1 + "", interpolate0;\n  return function() {\n    var string0 = this.getAttribute(name);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);\n  };\n}\nfunction attrConstantNS(fullname, interpolate2, value1) {\n  var string00, string1 = value1 + "", interpolate0;\n  return function() {\n    var string0 = this.getAttributeNS(fullname.space, fullname.local);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);\n  };\n}\nfunction attrFunction(name, interpolate2, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0, value1 = value(this), string1;\n    if (value1 == null) return void this.removeAttribute(name);\n    string0 = this.getAttribute(name);\n    string1 = value1 + "";\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));\n  };\n}\nfunction attrFunctionNS(fullname, interpolate2, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0, value1 = value(this), string1;\n    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);\n    string0 = this.getAttributeNS(fullname.space, fullname.local);\n    string1 = value1 + "";\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));\n  };\n}\nfunction transition_attr(name, value) {\n  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;\n  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));\n}\nfunction attrInterpolate(name, i) {\n  return function(t) {\n    this.setAttribute(name, i.call(this, t));\n  };\n}\nfunction attrInterpolateNS(fullname, i) {\n  return function(t) {\n    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));\n  };\n}\nfunction attrTweenNS(fullname, value) {\n  var t0, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);\n    return t0;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction attrTween(name, value) {\n  var t0, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);\n    return t0;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction transition_attrTween(name, value) {\n  var key = "attr." + name;\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== "function") throw new Error();\n  var fullname = namespace(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n}\nfunction delayFunction(id2, value) {\n  return function() {\n    init(this, id2).delay = +value.apply(this, arguments);\n  };\n}\nfunction delayConstant(id2, value) {\n  return value = +value, function() {\n    init(this, id2).delay = value;\n  };\n}\nfunction transition_delay(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;\n}\nfunction durationFunction(id2, value) {\n  return function() {\n    set(this, id2).duration = +value.apply(this, arguments);\n  };\n}\nfunction durationConstant(id2, value) {\n  return value = +value, function() {\n    set(this, id2).duration = value;\n  };\n}\nfunction transition_duration(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;\n}\nfunction easeConstant(id2, value) {\n  if (typeof value !== "function") throw new Error();\n  return function() {\n    set(this, id2).ease = value;\n  };\n}\nfunction transition_ease(value) {\n  var id2 = this._id;\n  return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;\n}\nfunction easeVarying(id2, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (typeof v !== "function") throw new Error();\n    set(this, id2).ease = v;\n  };\n}\nfunction transition_easeVarying(value) {\n  if (typeof value !== "function") throw new Error();\n  return this.each(easeVarying(this._id, value));\n}\nfunction transition_filter(match) {\n  if (typeof match !== "function") match = matcher(match);\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n  return new Transition(subgroups, this._parents, this._name, this._id);\n}\nfunction transition_merge(transition) {\n  if (transition._id !== this._id) throw new Error();\n  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n  return new Transition(merges, this._parents, this._name, this._id);\n}\nfunction start(name) {\n  return (name + "").trim().split(/^|\\s+/).every(function(t) {\n    var i = t.indexOf(".");\n    if (i >= 0) t = t.slice(0, i);\n    return !t || t === "start";\n  });\n}\nfunction onFunction(id2, name, listener) {\n  var on0, on1, sit = start(name) ? init : set;\n  return function() {\n    var schedule2 = sit(this, id2), on = schedule2.on;\n    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);\n    schedule2.on = on1;\n  };\n}\nfunction transition_on(name, listener) {\n  var id2 = this._id;\n  return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));\n}\nfunction removeFunction(id2) {\n  return function() {\n    var parent = this.parentNode;\n    for (var i in this.__transition) if (+i !== id2) return;\n    if (parent) parent.removeChild(this);\n  };\n}\nfunction transition_remove() {\n  return this.on("end.remove", removeFunction(this._id));\n}\nfunction transition_select(select) {\n  var name = this._name, id2 = this._id;\n  if (typeof select !== "function") select = selector(select);\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n        if ("__data__" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        schedule(subgroup[i], name, id2, i, subgroup, get(node, id2));\n      }\n    }\n  }\n  return new Transition(subgroups, this._parents, name, id2);\n}\nfunction transition_selectAll(select) {\n  var name = this._name, id2 = this._id;\n  if (typeof select !== "function") select = selectorAll(select);\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get(node, id2), k = 0, l = children2.length; k < l; ++k) {\n          if (child = children2[k]) {\n            schedule(child, name, id2, k, children2, inherit2);\n          }\n        }\n        subgroups.push(children2);\n        parents.push(node);\n      }\n    }\n  }\n  return new Transition(subgroups, parents, name, id2);\n}\nvar Selection = selection.prototype.constructor;\nfunction transition_selection() {\n  return new Selection(this._groups, this._parents);\n}\nfunction styleNull(name, interpolate2) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);\n  };\n}\nfunction styleRemove(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\nfunction styleConstant(name, interpolate2, value1) {\n  var string00, string1 = value1 + "", interpolate0;\n  return function() {\n    var string0 = styleValue(this, name);\n    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);\n  };\n}\nfunction styleFunction(name, interpolate2, value) {\n  var string00, string10, interpolate0;\n  return function() {\n    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";\n    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));\n    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));\n  };\n}\nfunction styleMaybeRemove(id2, name) {\n  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;\n  return function() {\n    var schedule2 = set(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;\n    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);\n    schedule2.on = on1;\n  };\n}\nfunction transition_style(name, value, priority) {\n  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;\n  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);\n}\nfunction styleInterpolate(name, i, priority) {\n  return function(t) {\n    this.style.setProperty(name, i.call(this, t), priority);\n  };\n}\nfunction styleTween(name, value, priority) {\n  var t, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);\n    return t;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction transition_styleTween(name, value, priority) {\n  var key = "style." + (name += "");\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== "function") throw new Error();\n  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));\n}\nfunction textConstant(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\nfunction textFunction(value) {\n  return function() {\n    var value1 = value(this);\n    this.textContent = value1 == null ? "" : value1;\n  };\n}\nfunction transition_text(value) {\n  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));\n}\nfunction textInterpolate(i) {\n  return function(t) {\n    this.textContent = i.call(this, t);\n  };\n}\nfunction textTween(value) {\n  var t0, i0;\n  function tween() {\n    var i = value.apply(this, arguments);\n    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);\n    return t0;\n  }\n  tween._value = value;\n  return tween;\n}\nfunction transition_textTween(value) {\n  var key = "text";\n  if (arguments.length < 1) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== "function") throw new Error();\n  return this.tween(key, textTween(value));\n}\nfunction transition_transition() {\n  var name = this._name, id0 = this._id, id1 = newId();\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        var inherit2 = get(node, id0);\n        schedule(node, name, id1, i, group, {\n          time: inherit2.time + inherit2.delay + inherit2.duration,\n          delay: 0,\n          duration: inherit2.duration,\n          ease: inherit2.ease\n        });\n      }\n    }\n  }\n  return new Transition(groups, this._parents, name, id1);\n}\nfunction transition_end() {\n  var on0, on1, that = this, id2 = that._id, size = that.size();\n  return new Promise(function(resolve, reject) {\n    var cancel = { value: reject }, end = { value: function() {\n      if (--size === 0) resolve();\n    } };\n    that.each(function() {\n      var schedule2 = set(this, id2), on = schedule2.on;\n      if (on !== on0) {\n        on1 = (on0 = on).copy();\n        on1._.cancel.push(cancel);\n        on1._.interrupt.push(cancel);\n        on1._.end.push(end);\n      }\n      schedule2.on = on1;\n    });\n    if (size === 0) resolve();\n  });\n}\nvar id = 0;\nfunction Transition(groups, parents, name, id2) {\n  this._groups = groups;\n  this._parents = parents;\n  this._name = name;\n  this._id = id2;\n}\nfunction newId() {\n  return ++id;\n}\nvar selection_prototype = selection.prototype;\nTransition.prototype = {\n  constructor: Transition,\n  select: transition_select,\n  selectAll: transition_selectAll,\n  selectChild: selection_prototype.selectChild,\n  selectChildren: selection_prototype.selectChildren,\n  filter: transition_filter,\n  merge: transition_merge,\n  selection: transition_selection,\n  transition: transition_transition,\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: transition_on,\n  attr: transition_attr,\n  attrTween: transition_attrTween,\n  style: transition_style,\n  styleTween: transition_styleTween,\n  text: transition_text,\n  textTween: transition_textTween,\n  remove: transition_remove,\n  tween: transition_tween,\n  delay: transition_delay,\n  duration: transition_duration,\n  ease: transition_ease,\n  easeVarying: transition_easeVarying,\n  end: transition_end,\n  [Symbol.iterator]: selection_prototype[Symbol.iterator]\n};\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\nvar defaultTiming = {\n  time: null,\n  // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: cubicInOut\n};\nfunction inherit(node, id2) {\n  var timing;\n  while (!(timing = node.__transition) || !(timing = timing[id2])) {\n    if (!(node = node.parentNode)) {\n      throw new Error(`transition ${id2} not found`);\n    }\n  }\n  return timing;\n}\nfunction selection_transition(name) {\n  var id2, timing;\n  if (name instanceof Transition) {\n    id2 = name._id, name = name._name;\n  } else {\n    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";\n  }\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        schedule(node, name, id2, i, group, timing || inherit(node, id2));\n      }\n    }\n  }\n  return new Transition(groups, this._parents, name, id2);\n}\nselection.prototype.interrupt = selection_interrupt;\nselection.prototype.transition = selection_transition;\nfunction Transform(k, x, y) {\n  this.k = k;\n  this.x = x;\n  this.y = y;\n}\nTransform.prototype = {\n  constructor: Transform,\n  scale: function(k) {\n    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);\n  },\n  translate: function(x, y) {\n    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);\n  },\n  apply: function(point) {\n    return [point[0] * this.k + this.x, point[1] * this.k + this.y];\n  },\n  applyX: function(x) {\n    return x * this.k + this.x;\n  },\n  applyY: function(y) {\n    return y * this.k + this.y;\n  },\n  invert: function(location) {\n    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n  },\n  invertX: function(x) {\n    return (x - this.x) / this.k;\n  },\n  invertY: function(y) {\n    return (y - this.y) / this.k;\n  },\n  rescaleX: function(x) {\n    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));\n  },\n  rescaleY: function(y) {\n    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));\n  },\n  toString: function() {\n    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";\n  }\n};\nTransform.prototype;\nconst noInterpolation = (values, index) => {\n  return Number(values[index]);\n};\nconst interpolateLinear = (values, index, xFraction, yFraction, ranges) => {\n  const nx = ranges[1]["end"] - ranges[1]["start"];\n  const p0 = Number(values[index]);\n  let p1 = Number(values[index + 1]);\n  const p2 = Number(values[index + nx]);\n  let p3 = Number(values[index + 1 + nx]);\n  if ((index + 1) % nx == 0) {\n    p1 = p0;\n    p3 = p0;\n  }\n  return p0 * (1 - xFraction) * (1 - yFraction) + p1 * xFraction * (1 - yFraction) + p2 * (1 - xFraction) * yFraction + p3 * xFraction * yFraction;\n};\nconst cardinalSpline = (t, p0, p1, p2, p3, tension) => {\n  const t2 = t * t;\n  const t3 = t2 * t;\n  const s = (1 - tension) / 2;\n  return s * (-t3 + 2 * t2 - t) * p0 + s * (-t3 + t2) * p1 + (2 * t3 - 3 * t2 + 1) * p1 + s * (t3 - 2 * t2 + t) * p2 + (-2 * t3 + 3 * t2) * p2 + s * (t3 - t2) * p3;\n};\nconst interpolateCardinal2D = (values, nx, index, xFraction, yFraction, tension = 0) => {\n  const r0 = cardinalSpline(\n    xFraction,\n    Number(values[index + -1 * nx - 1]),\n    Number(values[index + -1 * nx + 0]),\n    Number(values[index + -1 * nx + 1]),\n    Number(values[index + -1 * nx + 2]),\n    tension\n  );\n  const r1 = cardinalSpline(\n    xFraction,\n    Number(values[index + 0 * nx - 1]),\n    Number(values[index + 0 * nx + 0]),\n    Number(values[index + 0 * nx + 1]),\n    Number(values[index + 0 * nx + 2]),\n    tension\n  );\n  const r2 = cardinalSpline(\n    xFraction,\n    Number(values[index + 1 * nx - 1]),\n    Number(values[index + 1 * nx + 0]),\n    Number(values[index + 1 * nx + 1]),\n    Number(values[index + 1 * nx + 2]),\n    tension\n  );\n  const r3 = cardinalSpline(\n    xFraction,\n    Number(values[index + 2 * nx - 1]),\n    Number(values[index + 2 * nx + 0]),\n    Number(values[index + 2 * nx + 1]),\n    Number(values[index + 2 * nx + 2]),\n    tension\n  );\n  return cardinalSpline(yFraction, r0, r1, r2, r3, tension);\n};\nconst interpolate2DHermite = (values, index, xFraction, yFraction, ranges) => {\n  const nx = ranges[1]["end"] - ranges[1]["start"];\n  return interpolateCardinal2D(values, nx, index, xFraction, yFraction, 0.3);\n};\nfunction interpolateColorScaleHSL(colors, steps) {\n  const segments = colors.length - 1;\n  const stepsPerSegment = Math.floor(steps / segments);\n  const remainder = steps % segments;\n  const rgbArray = [];\n  for (let i = 0; i < segments; i++) {\n    const startColor = colors[i];\n    const endColor = colors[i + 1];\n    const interpolate2 = interpolateHsl(startColor, endColor);\n    const numSteps = stepsPerSegment + (i < remainder ? 1 : 0);\n    for (let j = 0; j < numSteps; j++) {\n      const t = j / (numSteps - 1);\n      let c = color(interpolate2(t));\n      if (c) {\n        c = c.rgb();\n        rgbArray.push([c.r, c.g, c.b]);\n      }\n    }\n  }\n  return rgbArray;\n}\nconst precipScale = {\n  min: 0,\n  max: 20,\n  scalefactor: 1,\n  colors: [\n    ...interpolateColorScaleHSL(["blue", "green"], 5),\n    // 0 to 5mm\n    ...interpolateColorScaleHSL(["green", "orange"], 5),\n    // 5 to 10mm\n    ...interpolateColorScaleHSL(["orange", "red"], 10)\n    // 10 to 20mm\n  ],\n  interpolationMethod: "linear",\n  unit: "mm"\n};\nconst convectiveCloudScale = {\n  min: 0,\n  max: 6e3,\n  scalefactor: 1,\n  colors: [\n    ...interpolateColorScaleHSL(["#c0392b", "#d35400", "#f1c40f", "#16a085", "#2980b9"], 6e3)\n  ],\n  interpolationMethod: "none",\n  unit: "m"\n};\nconst colorScales = {\n  cape: {\n    min: 0,\n    max: 4e3,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(\n        ["#009392", "#39b185", "#9ccb86", "#e9e29c", "#eeb479", "#e88471", "#cf597e"],\n        4e3\n      )\n    ],\n    interpolationMethod: "linear",\n    unit: ""\n  },\n  cloud_base: {\n    min: 0,\n    max: 20900,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(["#FFF", "#c3c2c2"], 20900)\n      // 0 to 20900m\n    ],\n    interpolationMethod: "linear",\n    unit: "m"\n  },\n  cloud_cover: {\n    min: 0,\n    max: 100,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(["#FFF", "#c3c2c2"], 100)\n      // 0 to 100%\n    ],\n    interpolationMethod: "linear",\n    unit: "%"\n  },\n  convective_cloud_top: convectiveCloudScale,\n  convective_cloud_base: convectiveCloudScale,\n  precipitation: precipScale,\n  pressure: {\n    min: 950,\n    max: 1050,\n    scalefactor: 0.5,\n    colors: [\n      ...interpolateColorScaleHSL(["#4444FF", "#FFFFFF"], 25),\n      // 950 to 1000hPa\n      ...interpolateColorScaleHSL(["#FFFFFF", "#FF4444"], 25)\n      // 1000hPa to 1050hPa\n    ],\n    interpolationMethod: "linear",\n    unit: "hPa"\n  },\n  rain: precipScale,\n  relative: {\n    min: 0,\n    max: 100,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(\n        ["#009392", "#39b185", "#9ccb86", "#e9e29c", "#eeb479", "#e88471", "#cf597e"].reverse(),\n        100\n      )\n    ],\n    interpolationMethod: "linear",\n    unit: "%"\n  },\n  shortwave: {\n    min: 0,\n    max: 1e3,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(\n        ["#009392", "#39b185", "#9ccb86", "#e9e29c", "#eeb479", "#e88471", "#cf597e"],\n        1e3\n      )\n    ],\n    interpolationMethod: "linear",\n    unit: "W/m^2"\n  },\n  temperature: {\n    min: -40,\n    max: 60,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(["purple", "blue"], 40),\n      // -40°C to 0°C\n      ...interpolateColorScaleHSL(["blue", "green"], 16),\n      // 0°Cto 16°C\n      ...interpolateColorScaleHSL(["green", "orange"], 12),\n      // 0°C to 28°C\n      ...interpolateColorScaleHSL(["orange", "red"], 14),\n      // 28°C to 42°C\n      ...interpolateColorScaleHSL(["red", "purple"], 18)\n      // 42°C to 60°C\n    ],\n    interpolationMethod: "linear",\n    unit: "C°"\n  },\n  thunderstorm: {\n    min: 0,\n    max: 100,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(["blue", "green"], 33),\n      //\n      ...interpolateColorScaleHSL(["green", "orange"], 33),\n      //\n      ...interpolateColorScaleHSL(["orange", "red"], 34)\n      //\n    ],\n    interpolationMethod: "linear",\n    unit: "%"\n  },\n  swell: {\n    min: 0,\n    max: 10,\n    scalefactor: 5,\n    colors: [\n      ...interpolateColorScaleHSL(["blue", "green"], 10),\n      // 0 to 2m\n      ...interpolateColorScaleHSL(["green", "orange"], 20),\n      // 2 to 6m\n      ...interpolateColorScaleHSL(["orange", "red"], 20)\n      // 6 to 10m\n    ],\n    interpolationMethod: "linear",\n    unit: "m"\n  },\n  uv: {\n    min: 0,\n    max: 12,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(\n        ["#009392", "#39b185", "#9ccb86", "#e9e29c", "#eeb479", "#e88471", "#cf597e"],\n        12\n      )\n    ],\n    interpolationMethod: "linear",\n    unit: ""\n  },\n  wave: {\n    min: 0,\n    max: 10,\n    scalefactor: 5,\n    colors: [\n      ...interpolateColorScaleHSL(["blue", "green"], 10),\n      // 0 to 2m\n      ...interpolateColorScaleHSL(["green", "orange"], 20),\n      // 2 to 6m\n      ...interpolateColorScaleHSL(["orange", "red"], 20)\n      // 6 to 10m\n    ],\n    interpolationMethod: "linear",\n    unit: "m"\n  },\n  wind: {\n    min: 0,\n    max: 40,\n    scalefactor: 1,\n    colors: [\n      ...interpolateColorScaleHSL(["blue", "green"], 10),\n      // 0 to 10kn\n      ...interpolateColorScaleHSL(["green", "orange"], 10),\n      // 10 to 20kn\n      ...interpolateColorScaleHSL(["orange", "red"], 20)\n      // 20 to 40kn\n    ],\n    interpolationMethod: "linear",\n    unit: "m/s"\n  }\n};\nfunction getColorScale(variable) {\n  return colorScales[variable] ?? colorScales[variable.split("_")[0]] ?? colorScales[variable.split("_")[0] + "_" + variable.split("_")[1]] ?? colorScales["temperature"];\n}\nfunction getInterpolator(colorScale) {\n  if (!colorScale.interpolationMethod || colorScale.interpolationMethod === "none") {\n    return noInterpolation;\n  } else if (colorScale.interpolationMethod === "linear") {\n    return interpolateLinear;\n  } else if (colorScale.interpolationMethod === "hermite2d") {\n    return interpolate2DHermite;\n  } else {\n    return interpolateLinear;\n  }\n}\nconst TILE_SIZE = (Number(void 0) ?? 256) * 2;\nconst OPACITY = Number(void 0) ?? 75;\nconst drawArrow = (rgba2, iBase, jBase, x, y, z, ranges, domain, latLonMinMax, variable, projectionGrid, values, directions, boxSize = TILE_SIZE / 8, iconPixelData, interpolator) => {\n  const northArrow = iconPixelData["0"];\n  const iCenter = iBase + Math.floor(boxSize / 2);\n  const jCenter = jBase + Math.floor(boxSize / 2);\n  const lat = tile2lat(y + iCenter / TILE_SIZE, z);\n  const lon = tile2lon(x + jCenter / TILE_SIZE, z);\n  const { index, xFraction, yFraction } = getIndexAndFractions(\n    lat,\n    lon,\n    domain,\n    projectionGrid,\n    ranges,\n    latLonMinMax\n  );\n  const px = interpolator(values, index, xFraction, yFraction, ranges);\n  const direction = degreesToRadians(interpolator(directions, index, xFraction, yFraction, ranges));\n  if (direction) {\n    for (let i = 0; i < boxSize; i++) {\n      for (let j = 0; j < boxSize; j++) {\n        const ind = j + i * boxSize;\n        const rotatedPoint = rotatePoint(\n          Math.floor(boxSize / 2),\n          Math.floor(boxSize / 2),\n          -direction,\n          i,\n          j\n        );\n        const newI = Math.floor(rotatedPoint[0]);\n        const newJ = Math.floor(rotatedPoint[1]);\n        const indTile = jBase + newJ + (iBase + newI) * TILE_SIZE;\n        let opacityValue;\n        if (variable.value.startsWith("wind")) {\n          opacityValue = Math.min((px - 2) / 200 * 50, 100);\n        } else {\n          opacityValue = 0.8;\n        }\n        if (northArrow[4 * ind + 3]) {\n          rgba2[4 * indTile] = 0;\n          rgba2[4 * indTile + 1] = 0;\n          rgba2[4 * indTile + 2] = 0;\n          rgba2[4 * indTile + 3] = Number(northArrow[4 * ind + 3]) * opacityValue * (OPACITY / 50);\n        }\n      }\n    }\n  }\n};\nconst getColor = (colorScale, px) => {\n  return colorScale.colors[Math.min(\n    colorScale.colors.length - 1,\n    Math.max(0, Math.floor((px - colorScale.min) * colorScale.scalefactor))\n  )];\n};\nconst getOpacity = (v, px, dark) => {\n  if (v == "cloud_cover" || v == "thunderstorm_probability") {\n    return 255 * (px ** 1.5 / 1e3) * (OPACITY / 100);\n  } else if (v.startsWith("cloud_base")) {\n    return Math.min(1 - px / 20900, 1) * 255 * (OPACITY / 100);\n  } else if (v.startsWith("precipitation")) {\n    return Math.min(px / 1.5, 1) * 255 * (OPACITY / 100);\n  } else if (v.startsWith("wind")) {\n    return Math.min((px - 2) / 12, 1) * 255 * (OPACITY / 100);\n  } else {\n    return 255 * (dark ? OPACITY / 100 - 0.2 : OPACITY / 100);\n  }\n};\nconst getIndexAndFractions = (lat, lon, domain, projectionGrid, ranges = [\n  { start: 0, end: domain.grid.ny },\n  { start: 0, end: domain.grid.nx }\n], latLonMinMax) => {\n  let indexObject;\n  if (domain.grid.projection && projectionGrid) {\n    indexObject = projectionGrid.findPointInterpolated(lat, lon, ranges);\n  } else {\n    indexObject = getIndexFromLatLong(\n      lat,\n      lon,\n      domain.grid.dx,\n      domain.grid.dy,\n      ranges[1]["end"] - ranges[1]["start"],\n      latLonMinMax\n    );\n  }\n  return indexObject ?? {\n    index: NaN,\n    xFraction: 0,\n    yFraction: 0\n  };\n};\nself.onmessage = async (message) => {\n  if (message.data.type == "GT") {\n    const key = message.data.key;\n    const x = message.data.x;\n    const y = message.data.y;\n    const z = message.data.z;\n    const values = message.data.data.values;\n    const ranges = message.data.ranges;\n    const domain = message.data.domain;\n    const variable = message.data.variable;\n    const colorScale = getColorScale(message.data.variable.value);\n    const pixels = TILE_SIZE * TILE_SIZE;\n    const rgba2 = new Uint8ClampedArray(pixels * 4);\n    const dark = message.data.dark;\n    let projectionGrid = null;\n    if (domain.grid.projection) {\n      const projectionName = domain.grid.projection.name;\n      const projection = new DynamicProjection(\n        projectionName,\n        domain.grid.projection\n      );\n      projectionGrid = new ProjectionGrid(projection, domain.grid, ranges);\n    }\n    const interpolator = getInterpolator(colorScale);\n    const lonMin = domain.grid.lonMin + domain.grid.dx * ranges[1]["start"];\n    const latMin = domain.grid.latMin + domain.grid.dy * ranges[0]["start"];\n    const lonMax = domain.grid.lonMin + domain.grid.dx * ranges[1]["end"];\n    const latMax = domain.grid.latMin + domain.grid.dy * ranges[0]["end"];\n    for (let i = 0; i < TILE_SIZE; i++) {\n      const lat = tile2lat(y + i / TILE_SIZE, z);\n      for (let j = 0; j < TILE_SIZE; j++) {\n        const ind = j + i * TILE_SIZE;\n        const lon = tile2lon(x + j / TILE_SIZE, z);\n        const { index, xFraction, yFraction } = getIndexAndFractions(\n          lat,\n          lon,\n          domain,\n          projectionGrid,\n          ranges,\n          [latMin, lonMin, latMax, lonMax]\n        );\n        let px = interpolator(values, index, xFraction, yFraction, ranges);\n        if (hideZero.includes(variable.value)) {\n          if (px < 0.25) {\n            px = NaN;\n          }\n        }\n        if (isNaN(px) || px === Infinity || variable.value === "weather_code") {\n          rgba2[4 * ind] = 0;\n          rgba2[4 * ind + 1] = 0;\n          rgba2[4 * ind + 2] = 0;\n          rgba2[4 * ind + 3] = 0;\n        } else {\n          const color2 = getColor(colorScale, px);\n          if (color2) {\n            rgba2[4 * ind] = color2[0];\n            rgba2[4 * ind + 1] = color2[1];\n            rgba2[4 * ind + 2] = color2[2];\n            rgba2[4 * ind + 3] = getOpacity(variable.value, px, dark);\n          }\n        }\n      }\n    }\n    if (variable.value.startsWith("wave") && !variable.value.includes("_period") || variable.value.startsWith("wind") && !variable.value.includes("_gusts") && !variable.value.includes("_wave") || drawOnTiles.includes(variable.value)) {\n      if (variable.value.startsWith("wave") || variable.value.startsWith("wind")) {\n        const iconPixelData = message.data.iconPixelData;\n        const directions = message.data.data.directions;\n        const boxSize = Math.floor(TILE_SIZE / 16);\n        for (let i = 0; i < TILE_SIZE; i += boxSize) {\n          for (let j = 0; j < TILE_SIZE; j += boxSize) {\n            drawArrow(\n              rgba2,\n              i,\n              j,\n              x,\n              y,\n              z,\n              ranges,\n              domain,\n              [latMin, lonMin, latMax, lonMax],\n              variable,\n              projectionGrid,\n              values,\n              directions,\n              boxSize,\n              iconPixelData,\n              interpolator\n            );\n          }\n        }\n      }\n    }\n    const tile = await createImageBitmap(new ImageData(rgba2, TILE_SIZE, TILE_SIZE));\n    postMessage({ type: "RT", tile, key });\n  }\n};\n';
const blob = typeof self !== "undefined" && self.Blob && new Blob(["URL.revokeObjectURL(import.meta.url);", jsContent], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      type: "module",
      name: options?.name
    });
    worker.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e) {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(jsContent),
      {
        type: "module",
        name: options?.name
      }
    );
  }
}
class WorkerPool {
  constructor() {
    this.workers = [];
    this.nextWorker = 0;
    this.pendingTiles = /* @__PURE__ */ new Map();
    this.resolvers = /* @__PURE__ */ new Map();
    if (typeof window === "undefined" || typeof Worker === "undefined") {
      return;
    }
    const workerCount = navigator.hardwareConcurrency || 4;
    for (let i = 0; i < workerCount; i++) {
      const worker = new WorkerWrapper();
      worker.onmessage = (message) => this.handleMessage(message);
      this.workers.push(worker);
    }
  }
  handleMessage(message) {
    const data = message.data;
    if (data.type === "RT") {
      const resolve = this.resolvers.get(data.key);
      if (resolve) {
        resolve(data.tile);
        this.resolvers.delete(data.key);
        this.pendingTiles.delete(data.key);
      } else {
        console.error(`Unexpected tile response for ${data.key}`);
      }
    }
  }
  getNextWorker() {
    if (this.workers.length === 0) return void 0;
    const worker = this.workers[this.nextWorker];
    this.nextWorker = (this.nextWorker + 1) % this.workers.length;
    return worker;
  }
  requestTile(request) {
    const existingPromise = this.pendingTiles.get(request.key);
    if (existingPromise) {
      return existingPromise;
    }
    const worker = this.getNextWorker();
    if (!worker) {
      return Promise.reject(new Error("No workers available (likely running in SSR)"));
    }
    const promise = new Promise((resolve) => {
      this.resolvers.set(request.key, resolve);
    });
    this.pendingTiles.set(request.key, promise);
    worker.postMessage(request);
    return promise;
  }
}
export {
  WorkerPool
};
